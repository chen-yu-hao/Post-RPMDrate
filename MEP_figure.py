'''
To my respective fellows Yang Hui and Fang Junhua!

Author: Wenbin FAN
Version: 1.2
Date: Nov. 30, 2019

Function:
(1) Draw the "MEP"(minimum energy path) and "MEP + ZPE"(zero point energy)
from the result file generated by Polyrate.
(2) Calculate the second derivative at the global maximum point, using the
fitted 6th polynomial function.

Usage:
Run `Python <this file name>` and input the folder containing the result
file. Then
(1) the figure will be generated in the current folder immediately,
(2) All data will be regenerated in the result folder in a formatted
manner. Please attention that the unit has been converted to eV.
(3) The derivative will be shown in the current command window,
Enjoy!

Bug Fix:
V1.1:
1) Shift ZPE and V both.
2) Plot first 2 columns rather than add them up and plot the summation.
3) Judge `Classical barrier is less than zero` and output to screen.
V1.2:
1) Grep frequency, export them to file and plot them. The Unit of Reaction
   coordinate is `amu^{1/2}Bohr`.
'''

import os

import matplotlib.pyplot as plt
import numpy as np
import numpy.polynomial.polynomial as poly
import pandas as pd

color = ['#00447c', '#ae0d16', '#47872c', '#800964']
# SHU Blue, Weichang Red, Willow Green, SHU Purple
# This color scheme can be easily obtained on the official website `vi.shu.edu.cn`.


def plot_parameters():
    plt.figure(figsize=(4, 3))
    plt.rcParams["font.family"] = "Times New Roman"
    plt.rcParams["mathtext.fontset"] = "stix"  # The font closet to Times New Roman
    plt.rcParams['xtick.direction'] = 'in'
    plt.rcParams['ytick.direction'] = 'in'
    plt.rcParams['ytick.right'] = True
    plt.rcParams['ytick.left'] = True
    plt.rcParams['xtick.top'] = True
    plt.minorticks_on()

    # if os.path.exists('MEP.png'):
    #     os.remove('MEP.png')


def findOutputFile(path):
    fileList = os.listdir(path)
    for file in fileList:
        if file.split('.')[-1] == 'fu6':
            return path + '/' + file


def extractAtomList(filePath):
    inRange = None
    global atomList
    atomList = []

    f = open(filePath, 'r')
    for line in f:
        if inRange == None and line == '            Atom     Atomic number    Atomic Symbol     Mass (amu)\n':
            inRange = True
        elif inRange == True:
            if len(line.split()) == 4:
                atomList.append(line.split()[2])
            elif line == '--------------------------------------------------------------------------------\n':
                inRange = False
        elif inRange == False:
            break

    f.close()
    return atomList


def extractMEP(filePath):
    newPath = filePath.replace('.fu6', '') + '_MEP.txt'

    if os.path.exists(newPath):
        os.remove(newPath)

    outRange = False
    with open(filePath, 'r') as f, open(newPath, 'w') as g:
        for line in f:
            if outRange:
                if line[:10] == ' *********':
                    break
                elif line[:10] == ' The Class':  # `The Classical barrier is less than zero!` # Not 'no barrier'!
                    print('[WARNING] The Classical barrier is less than zero! ')
                    break
                else:
                    print(line, file=g, end='')
            else:
                if line[:27] == '    Classical and adiabatic':
                    outRange = True
                    print(line, file=g, end='')
    return newPath


def extractPathCoord(filePath):
    newPath = filePath.replace('.fu6', '') + '_PathCoord.xyz'
    enePath = filePath.replace('.fu6', '') + '_PathEnergy.txt'

    for i in [newPath, enePath]:
        if os.path.exists(i):
            os.remove(i)

    # Determine whether there will be coordinates
    PRINTSTEP = False
    with open(filePath, 'r') as f:
        for line in f:
            if line == '    PRINTSTEP:  print geom, v, and grad at each step             on \n':
                print('[INFO] `PRINTSTEP` is turned on. ')
                PRINTSTEP = True
                break
            elif line == '    PRINTSTEP:  print geom, v, and grad at each step             off\n':
                print('[ERROR] `PRINTSTEP` is turned off! No coordinates will be exported. ')
                PRINTSTEP = False
                break
            else:
                PRINTSTEP = None

    if PRINTSTEP == None:
        print('[ERROR] Your `.fu6` file maybe not integrity! ')
        return

    # Find the number of steps
    Npoints = []
    twoSide = 0
    with open(filePath, 'r') as f:
        for line in f:
            if line[:36] == '     number of integration steps was':
                num = np.int(line.split()[-1])
                print('[INFO] There are {} points in direction {}. '.format(num, twoSide))
                Npoints.append(num)
                twoSide += 1
                if twoSide == 2:
                    break
    NpointsLeft = Npoints[0]
    NpointsRight = Npoints[1]
    Npoints = np.sum(Npoints)

    # Create blank array: 3 * Natoms * Npoints
    Natoms = len(atomList)
    coord = np.zeros([3, Natoms, Npoints])
    xiEne = np.zeros([2, Npoints])  # (xi/amu^{1/2}Bohr) + (energy/Hartree)

    # read all coordinates from file
    inRange = None  # determine whether in the range of path coordinates
    inAtom = 0  # determin whether in the range of atom
    countPoints = 0
    if PRINTSTEP == True:
        f = open(filePath, 'r')
        for line in f:
            if inRange == None and line == '                       (DX,DY,DZ in unscaled hartree/bohr)\n':
                inRange = True
            if inRange == True:
                if line[:4] == ' s =':
                    lineXiEne = line.split()
                    xiEne[:, countPoints] = [lineXiEne[2], lineXiEne[5]]
                if inAtom > 0 and inAtom <= Natoms:
                    xyzFloats = [np.float(x) * 0.52191772E0 for x in line.split()[1:]]  # `1:4` is also okay!
                    coord[:, inAtom - 1, countPoints] = xyzFloats
                    inAtom += 1
                elif line == '  Atom           X              Y              Z\n':
                    inAtom = 1
                    countPoints += 1
                if countPoints == Npoints:
                    inRange = False
                    break
            elif inRange == False:
                break
    f.close()

    # delete first step in each direction # for they are the coordinates that user input which are artificial.
    coord = np.delete(coord, [0, NpointsRight], axis=2)
    xiEne = np.delete(xiEne, [0, NpointsRight], axis=1)

    # sort coordinates by xi
    orderXi = np.argsort(xiEne, axis=1)
    for i in range(3):
        for j in range(Natoms):
            temp = coord[i, j, :]
            coord[i, j, :] = np.take_along_axis(temp, orderXi[0, :], axis=0)
    xiEne = np.sort(xiEne, axis=1)

    # write coordinates to file
    g = open(newPath, 'w')
    h = open(enePath, 'w')

    for points in range(Npoints - 2):
        g.write('{}\n'.format(Natoms))
        title = '{0:.6f} {1:.6f} \n'.format(xiEne[0, points], xiEne[1, points])
        g.write(title)
        h.write(title)
        for atom in range(Natoms):  # [1,3,4,5,6,2,0]: # My OHCH4 order
            g.write('{0:}\t{1:.6f}\t{2:.6f}\t{3:.6f}\n'.
                    format(atomList[atom], coord[0, atom, points], coord[1, atom, points], coord[2, atom, points]))

    g.close()
    h.close()


def readData(filePath):
    count = 0

    freqPath = filePath.replace('_MEP.txt', '') + '_FreqData.txt'
    freqFile = open(freqPath, 'w')

    xi = []
    V = []
    VZPE = []
    muCD = []  # I DN what is muCD, just collect the data like a robot #
    with open(filePath, 'r') as f:
        for line in f:
            if count > 3:
                if line[:10] != '          ' and line != '\n':
                    lineText = line.split()
                    xi.append(np.float(lineText[0]))
                    V.append(np.float(lineText[1]))  # * 0.0433634) # kcal/mol to eV
                    VZPE.append(np.float(lineText[2]))  # * 0.0433634) # kcal/mol to eV
                    muCD.append(np.float(lineText[3]))
                    # Write freq to file
                    freqFile.write('\n')
                    freqFile.flush()
                    freqline = line[37:].replace('\n', '').split()
                    freqFile.write('{}\t'.format(xi[-1]))
                    freqFile.flush()
                    for freq in freqline:
                        if freq[-1] == 'i':
                            freq = np.float(freq.replace('i', '')) * (-1.0)
                        freq = np.float(freq)
                        freqFile.write('{}\t'.format(freq / 1000.0))
                        freqFile.flush()
                elif line[:10] == '          ' and line != '\n':
                    freqline = line[37:].replace('\n', '').split()
                    for freq in freqline:
                        if freq[-1] == 'i':
                            freq = np.float(freq.replace('i', '')) * (-1.0)
                        freq = np.float(freq)
                        freqFile.write('{}\t'.format(freq / 1000.0))
            count += 1

    assert len(xi) == len(V) == len(VZPE) == len(muCD)

    # Shift the energy to positive
    VZPE = [VZPE[i] - V[0] for i in range(len(V))]
    V = [V[i] - V[0] for i in range(len(V))]

    ZPE = []
    for i in range(len(V)):
        ZPE.append(VZPE[i] - V[i])

    dataPath = filePath.replace('.txt', '') + '_Data.txt'
    with open(dataPath, 'w') as f:
        #        print('s/Angstrom\tV\tZPE\tV+ZPE', file=f)
        #        for i in range(len(xi)):
        #            print('{0:.4f}\t{1:.8f}\t{2:.8f}\t{3:.8f}'.format(xi[i], V[i], ZPE[i], VZPE[i]), file=f)
        print('s\tV\tZPE\tVZPE\tmuCD', file=f)
        for i in range(len(xi)):
            print('{0:.4f}\t{1:.4f}\t{2:.4f}\t{3:.4f}\t{4:.4f}'
                  .format(xi[i], V[i], ZPE[i], VZPE[i], muCD[i]), file=f)

    os.remove(filePath)

    return dataPath, freqPath


def plotMEP(filePath):
    plot_parameters()

    a = pd.read_csv(filePath, sep='\t')

    xi = list(a.iloc[:, 0])
    V = list(a.iloc[:, 1])
    ZPE = list(a.iloc[:, 2])
    VZPE = list(a.iloc[:, 3])

    plt.plot(xi, V, c=color[0], label='MEP')
    plt.plot(xi, VZPE, dashes=[3, 3], c=color[0], label='$V_{\mathrm{a}}^{\mathrm{G}}$')
    plt.plot(xi, ZPE, ':', c=color[0], label='ZPE')

    plt.legend(loc="best")
    plt.xlabel('$s$ (amu$^{1/2}$Bohr)')
    plt.ylabel('Energy (kcal/mol)')

    plt.xlim(min(xi), max(xi))

    plt.tight_layout()

    calc2ndDer(xi, V)

    plt.savefig('MEP.png', format='png', dpi=600)
    plt.clf()
    plt.close()


def calc2ndDer(xi, V):
    xiMaxIndex = V.index(max(V))  # the position of maximum
    extend = 5  # Extra points to plot. Fifty points equal 0.1 extended to any direction.
    ximax = xi[xiMaxIndex - extend: xiMaxIndex + extend]
    Vmax = V[xiMaxIndex - extend: xiMaxIndex + extend]

    # plt.plot(ximax, Vmax, c=color[1])
    coeff = poly.polyfit(ximax, Vmax, 5)

    # Find the the point dy/dx=0
    coeffD = poly.polyder(coeff)
    rootD = poly.polyroots(coeffD)
    rootD_Re = []
    for root in rootD:
        rootD_Re.append(np.abs(np.real(root) - xi[xiMaxIndex]))
    rootIndex = rootD_Re.index(min(rootD_Re, key=abs))
    root = np.real(rootD[rootIndex])

    # Calc the d2y/dx2 at x=(dy/dx=0)
    coeffDD = poly.polyder(coeff, 2)
    dd = np.polyval(list(coeffDD)[::-1], root)

    # # a inner subplot
    # xifit = np.linspace(ximax[0], ximax[-1], 1000)
    # Vfit  = np.polyval(list(coeff)[::-1], xifit)
    # plt.plot(xifit, Vfit, c=(1, 0, 0), lw=1, label='Fitted MEP')
    #
    # subFig = plt.axes([0.3, 0.5, 0.2, 0.2])
    # subFig.plot(ximax, Vmax, dashes=[4, 4], c=color[0], lw=2)
    # subFig.plot(xifit, Vfit, c=(1,0,0), lw=0.8)
    # subFig.minorticks_on()
    # plt.setp(subFig, xlim=[min(ximax), max(ximax)])

    print('[INFO] The d^2y/dx^2 at xi = {0:.3e} is {1:.6f}. \n'
          '       Five times of this value is {2:.6f}. '.format(root, dd, dd * 5))


def plotFreq(path):
    plot_parameters()

    a = pd.read_csv(path, sep='\t')
    num = len(a.columns) - 1

    for rank in range(num):
        plt.plot(a.iloc[:, 0], a.iloc[:, rank + 1], lw=1)

    plt.xlabel('$s$ (amu$^{1/2}$Bohr)')
    plt.ylabel('Frequency (10$^3$ cm$^{-1}$)')

    plt.xlim(min(a.iloc[:, 0]), max(a.iloc[:, 0]))

    plt.tight_layout()
    plt.savefig('freq.png', format='png', dpi=600)
    plt.clf()
    plt.close()


def main(path=None):
    if path is None:
        path = input('Please input the folder consisting the output of Polyrate: \n')
    resultPath = findOutputFile(path)
    atomList = extractAtomList(resultPath)

    print('[INFO] Atoms: ', atomList)

    extractPathCoord(resultPath)

    MEPPath = extractMEP(resultPath)
    dataPath, freqPath = readData(MEPPath)
    plotMEP(dataPath)
    plotFreq(freqPath)


main(os.getcwd())
